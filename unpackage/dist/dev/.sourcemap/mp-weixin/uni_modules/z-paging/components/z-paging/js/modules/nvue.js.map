{"version":3,"file":"nvue.js","sources":["uni_modules/z-paging/components/z-paging/js/modules/nvue.js"],"sourcesContent":["// [z-paging]nvue独有部分模块\nimport u from '.././z-paging-utils'\nimport c from '.././z-paging-constant'\nimport Enum from '.././z-paging-enum'\n\n// #ifdef APP-NVUE\nconst weexAnimation = weex.requireModule('animation');\n// #endif\nexport default {\n\tprops: {\n\t\t// #ifdef APP-NVUE\n\t\t// nvue中修改列表类型，可选值有list、waterfall和scroller，默认为list\n\t\tnvueListIs: {\n\t\t\ttype: String,\n\t\t\tdefault: u.gc('nvueListIs', 'list')\n\t\t},\n\t\t// nvue waterfall配置，仅在nvue中且nvueListIs=waterfall时有效，配置参数详情参见：https://uniapp.dcloud.io/component/waterfall\n\t\tnvueWaterfallConfig: {\n\t\t\ttype: Object,\n\t\t\tdefault: u.gc('nvueWaterfallConfig', {})\n\t\t},\n\t\t// nvue 控制是否回弹效果，iOS不支持动态修改\n\t\tnvueBounce: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: u.gc('nvueBounce', true)\n\t\t},\n\t\t// nvue中通过代码滚动到顶部/底部时，是否加快动画效果(无滚动动画时无效)，默认为否\n\t\tnvueFastScroll: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: u.gc('nvueFastScroll', false)\n\t\t},\n\t\t// nvue中list的id\n\t\tnvueListId: {\n\t\t\ttype: String,\n\t\t\tdefault: u.gc('nvueListId', '')\n\t\t},\n\t\t// nvue中refresh组件的样式\n\t\tnvueRefresherStyle: {\n\t\t\ttype: Object,\n\t\t\tdefault: u.gc('nvueRefresherStyle', {})\n\t\t},\n\t\t// nvue中是否按分页模式(类似竖向swiper)显示List，默认为false\n\t\tnvuePagingEnabled: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: u.gc('nvuePagingEnabled', false)\n\t\t},\n\t\t// 是否隐藏nvue列表底部的tagView，此view用于标识滚动到底部位置，若隐藏则滚动到底部功能将失效，在nvue中实现吸顶+swiper功能时需将最外层z-paging的此属性设置为true。默认为否\n\t\thideNvueBottomTag: {\n\t\t\ttype: Boolean,\n\t\t\tdefault: u.gc('hideNvueBottomTag', false)\n\t\t},\n\t\t// nvue中控制onscroll事件触发的频率：表示两次onscroll事件之间列表至少滚动了10px。注意，将该值设置为较小的数值会提高滚动事件采样的精度，但同时也会降低页面的性能\n\t\toffsetAccuracy: {\n\t\t\ttype: Number,\n\t\t\tdefault: u.gc('offsetAccuracy', 10)\n\t\t},\n\t\t// #endif\n\t},\n\tdata() {\n\t\treturn {\n\t\t\tnRefresherLoading: false,\n\t\t\tnListIsDragging: false,\n\t\t\tnShowBottom: true,\n\t\t\tnFixFreezing: false,\n\t\t\tnShowRefresherReveal: false,\n\t\t\tnLoadingMoreFixedHeight: false,\n\t\t\tnShowRefresherRevealHeight: 0,\n\t\t\tnOldShowRefresherRevealHeight: -1,\n\t\t\tnRefresherWidth: u.rpx2px(750),\n\t\t\tnF2Opacity: 0\n\t\t}\n\t},\n\tcomputed: {\n\t\t// #ifdef APP-NVUE\n\t\tnScopedSlots() {\n\t\t\t// #ifdef VUE2\n\t\t\treturn this.$scopedSlots;\n\t\t\t// #endif\n\t\t\t// #ifdef VUE3\n\t\t\treturn null;\n\t\t\t// #endif\n\t\t},\n\t\tnWaterfallColumnCount() {\n\t\t\tif (this.finalNvueListIs !== 'waterfall') return 0;\n\t\t\treturn this._nGetWaterfallConfig('column-count', 2);\n\t\t},\n\t\tnWaterfallColumnWidth() {\n\t\t\treturn this._nGetWaterfallConfig('column-width', 'auto');\n\t\t},\n\t\tnWaterfallColumnGap() {\n\t\t\treturn this._nGetWaterfallConfig('column-gap', 'normal');\n\t\t},\n\t\tnWaterfallLeftGap() {\n\t\t\treturn this._nGetWaterfallConfig('left-gap', 0);\n\t\t},\n\t\tnWaterfallRightGap() {\n\t\t\treturn this._nGetWaterfallConfig('right-gap', 0);\n\t\t},\n\t\tnViewIs() {\n\t\t\tconst is = this.finalNvueListIs;\n\t\t\treturn is === 'scroller' || is === 'view' ? 'view' : is === 'waterfall' ? 'header' : 'cell';\n\t\t},\n\t\tnSafeAreaBottomHeight() {\n\t\t\treturn this.safeAreaInsetBottom ? this.safeAreaBottom : 0;\n\t\t},\n\t\tfinalNvueListIs() {\n\t\t\tif (this.usePageScroll) return 'view';\n\t\t\tconst nvueListIsLowerCase = this.nvueListIs.toLowerCase();\n\t\t\tif (['list','waterfall','scroller'].indexOf(nvueListIsLowerCase) !== -1) return nvueListIsLowerCase;\n\t\t\treturn 'list';\n\t\t},\n\t\tfinalNvueSuperListIs() {\n\t\t\treturn this.usePageScroll ? 'view' : 'scroller';\n\t\t},\n\t\tfinalNvueRefresherEnabled() {\n\t\t\treturn this.finalNvueListIs !== 'view' && this.finalRefresherEnabled && !this.nShowRefresherReveal && !this.useChatRecordMode;\n\t\t},\n\t\t// #endif\n\t},\n\tmounted(){\n\t\t// #ifdef APP-NVUE\n\t\t//旋转屏幕时更新宽度\n\t\tuni.onWindowResize((res) => {\n\t\t\t// this._nUpdateRefresherWidth();\n\t\t})\n\t\t// #endif\n\t},\n\tmethods: {\n\t\t// #ifdef APP-NVUE\n\t\t// 列表滚动时触发\n\t\t_nOnScroll(e) {\n\t\t\tthis.$emit('scroll', e);\n\t\t\tconst contentOffsetY = -e.contentOffset.y;\n\t\t\tthis.oldScrollTop = contentOffsetY;\n\t\t\tthis.nListIsDragging = e.isDragging;\n\t\t\tthis._checkShouldShowBackToTop(contentOffsetY, contentOffsetY - 1);\n\t\t},\n\t\t// 列表滚动结束\n\t\t_nOnScrollend(e) {\n\t\t\tthis.$emit('scrollend', e);\n\t\t\t\n\t\t\t// 判断是否滚动到顶部了\n\t\t\tif (e?.contentOffset?.y >= 0) {\n\t\t\t\tthis._emitScrollEvent('scrolltoupper');\n\t\t\t}\n\t\t\t// 判断是否滚动到底部了\n\t\t\tthis._getNodeClientRect('.zp-n-list').then(node => {\n\t\t\t\tif (node) {\n\t\t\t\t\tif (e?.contentSize?.height + e?.contentOffset?.y <= node[0].height) {\n\t\t\t\t\t\tthis._emitScrollEvent('scrolltolower');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t\t// 下拉刷新刷新中\n\t\t_nOnRrefresh() {\n\t\t\tif (this.nShowRefresherReveal) return;\n\t\t\t// 进入刷新状态\n\t\t\tthis.nRefresherLoading = true;\n\t\t\tif (this.refresherStatus === Enum.Refresher.GoF2) {\n\t\t\t\tthis._handleGoF2();\n\t\t\t\tthis.$nextTick(() => {\n\t\t\t\t\tthis._nRefresherEnd();\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tthis.refresherStatus = Enum.Refresher.Loading;\n\t\t\t\tthis._doRefresherLoad();\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t// 下拉刷新下拉中\n\t\t_nOnPullingdown(e) {\n\t\t\tif (this.refresherStatus === Enum.Refresher.Loading || (this.isIos && !this.nListIsDragging)) return;\n\t\t\tthis._emitTouchmove(e);\n\t\t\tlet { viewHeight, pullingDistance } = e;\n\t\t\t// 更新下拉刷新状态\n\t\t\t// 下拉刷新距离超过阈值\n\t\t\tif (pullingDistance >= viewHeight) {\n\t\t\t\t// 如果开启了下拉进入二楼并且下拉刷新距离超过进入二楼阈值，则当前下拉刷新状态为松手进入二楼，否则为松手立即刷新\n\t\t\t\t// (pullingDistance - viewHeight) + this.finalRefresherThreshold 不等同于pullingDistance，此处是为了兼容不同平台下拉相同距离pullingDistance不一致的问题，pullingDistance仅与viewHeight互相关联\n\t\t\t\tthis.refresherStatus = this.refresherF2Enabled && (pullingDistance - viewHeight) + this.finalRefresherThreshold >= this.finalRefresherF2Threshold ? Enum.Refresher.GoF2 : Enum.Refresher.ReleaseToRefresh;\n\t\t\t} else {\n\t\t\t\t// 下拉刷新距离未超过阈值，显示默认状态\n\t\t\t\tthis.refresherStatus = Enum.Refresher.Default;\n\t\t\t}\n\t\t},\n\t\t// 下拉刷新结束\n\t\t_nRefresherEnd(doEnd = true) {\n\t\t\tif (doEnd) {\n\t\t\t   this._nDoRefresherEndAnimation(0, -this.nShowRefresherRevealHeight); \n\t\t\t   !this.usePageScroll && this.$refs['zp-n-list'].resetLoadmore();\n\t\t\t   this.nRefresherLoading = false;\n\t\t\t}\n\t\t},\n\t\t// 执行主动触发下拉刷新动画\n\t\t_nDoRefresherEndAnimation(height, translateY, animate = true, checkStack = true) {\n\t\t\t// 清除下拉刷新相关timeout\n\t\t\tthis._cleanRefresherCompleteTimeout();\n\t\t\tthis._cleanRefresherEndTimeout();\n\t\t\t\n\t\t\tif (!this.finalShowRefresherWhenReload) {\n\t\t\t\t// 如果reload不需要自动展示下拉刷新view，则在complete duration结束后再把下拉刷新状态设置回默认\n\t\t\t\tthis.refresherEndTimeout = u.delay(() => {\n\t\t\t\t\tthis.refresherStatus = Enum.Refresher.Default;\n\t\t\t\t}, this.refresherCompleteDuration);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// 用户处理用户在短时间内多次调用reload的情况，此时下拉刷新view不需要重复显示，只需要保证最后一次reload对应的请求结束后收回下拉刷新view即可\n\t\t\tconst stackCount = this.refresherRevealStackCount;\n\t\t\tif (height === 0 && checkStack) {\n\t\t\t\tthis.refresherRevealStackCount --;\n\t\t\t\tif (stackCount > 1) return;\n\t\t\t\tthis.refresherEndTimeout = u.delay(() => {\n\t\t\t\t\tthis.refresherStatus = Enum.Refresher.Default;\n\t\t\t\t}, this.refresherCompleteDuration);\n\t\t\t}\n\t\t\tif (stackCount > 1) {\n\t\t\t\tthis.refresherStatus = Enum.Refresher.Loading;\n\t\t\t}\n\t\t\t\n\t\t\tconst duration = animate ? 200 : 0;\n\t\t\tif (this.nOldShowRefresherRevealHeight !== height) {\n\t\t\t\tif (height > 0) {\n\t\t\t\t\tthis.nShowRefresherReveal = true;\n\t\t\t\t}\n\t\t\t\t// 展示下拉刷新view\n\t\t\t\tweexAnimation.transition(this.$refs['zp-n-list-refresher-reveal'], {\n\t\t\t\t\tstyles: {\n\t\t\t\t\t\theight: `${height}px`,\n\t\t\t\t\t\ttransform: `translateY(${translateY}px)`,\n\t\t\t\t\t},\n\t\t\t\t\tduration,\n\t\t\t\t\ttimingFunction: 'linear',\n\t\t\t\t\tneedLayout: true,\n\t\t\t\t\tdelay: 0\n\t\t\t\t})\n\t\t\t}\n\t\t\tu.delay(() => {\n\t\t\t\tif (animate) {\n\t\t\t\t\tthis.nShowRefresherReveal = height > 0;\n\t\t\t\t}\n\t\t\t}, duration > 0 ? duration - 60 : 0);\n\t\t\tthis.nOldShowRefresherRevealHeight = height;\n\t\t},\n\t\t// 滚动到底部加载更多\n\t\t_nOnLoadmore() {\n\t\t\tif (this.nShowRefresherReveal || !this.totalData.length) return;\n\t\t\tthis.useChatRecordMode ? this.doChatRecordLoadMore() : this._onLoadingMore('toBottom');\n\t\t},\n\t\t// 获取nvue waterfall单项配置\n\t\t_nGetWaterfallConfig(key, defaultValue) {\n\t\t\treturn this.nvueWaterfallConfig[key] || defaultValue;\n\t\t},\n\t\t// 更新nvue 下拉刷新view容器的宽度\n\t\t_nUpdateRefresherWidth() {\n\t\t\tu.delay(() => {\n\t\t\t\tthis.$nextTick(()=>{\n\t\t\t\t\tthis._getNodeClientRect('.zp-n-list').then(node => {\n\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\tthis.nRefresherWidth = node[0].width || this.nRefresherWidth;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\t\n\t\t}\n\t\t// #endif\n\t}\n}\n"],"names":["u"],"mappings":";;AAQA,MAAe,aAAA;AAAA,EACd,OAAO,CAgDN;AAAA,EACD,OAAO;AACN,WAAO;AAAA,MACN,mBAAmB;AAAA,MACnB,iBAAiB;AAAA,MACjB,aAAa;AAAA,MACb,cAAc;AAAA,MACd,sBAAsB;AAAA,MACtB,yBAAyB;AAAA,MACzB,4BAA4B;AAAA,MAC5B,+BAA+B;AAAA,MAC/B,iBAAiBA,uDAAAA,EAAE,OAAO,GAAG;AAAA,MAC7B,YAAY;AAAA,IACZ;AAAA,EACD;AAAA,EACD,UAAU,CA8CT;AAAA,EACD,UAAS;AAAA,EAOR;AAAA,EACD,SAAS,CA2IR;AACF;;"}